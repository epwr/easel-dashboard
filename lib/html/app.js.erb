/* app.js.erb
 *
 * Author: Eric Power
 *
 * Description:
 *    This ERB file generates the javascript that runs the client side of the Easel
 *    Dashboard.
 */

// Key Variables
let ws_socket = new WebSocket("ws://" + location.hostname + ":" + location.port);
let current_cmd = null;
let keep_pane_contents = false; // Remove default contents when you run a command.
let commands = { <% $config[:commands].each do |command| %>
  <%= command[:id] %>: {
    is_running: false,
    content: "[Click 'Run' to run the command.]",
     name: "<%= command[:name] %>" },
  <% end %>
};
let dashboards = { <% $config[:dashboards].each do |dashboard| %>
  "<%= dashboard[:id] %>": {
    name: "<%= dashboard[:name] %>",
    elements: [
      <% dashboard[:elements].each do |element| %>
        {
          name: "<%= element[:name] %>",
          type: "<%= element[:type] %>",
          canvas: document.createElement("CANVAS"),
          config: {
            type: 'line',
            data: {
              labels: [],
              datasets: [
                <% element[:data].each_with_index do |datum, index| %>
                {
                  label:  "<%= datum[:name] %>",
                  data: [],
                  borderColor: "<%= $config[:colours][:primary] %>",
                },
                <% end %>
              ]
            }
          },
          data: [
            <% element[:data].each do |datum| %>
              {
                name: "<%= datum[:name] %>",
                store: []
              },
            <% end %> <%# end data loop %>
          ]
        },
      <% end %> <%# end element loop %>
    ]
  },
  <% end %> <%# end dashboard loop %>
};

// Turn cdashboards > elements > canvases into Charts
Object.keys(dashboards).forEach( (dashboard_id) => {
  Object.keys(dashboards[dashboard_id]['elements']).forEach( (element_id) => {
    let element = dashboards[dashboard_id]['elements'][element_id];
    element['chart'] = new Chart(
        element['canvas'],
        element['config'])
  })
});


/* Receive message
 *
 * Sets the WebSocket's onmessage handler to recieve the message and then process
 * it appropriately.
 */
ws_socket.onmessage = (event) => {

  pane = document.getElementById('output-pane');
  console.log("Received: " + event.data);

  // If msg is about a command, or a dashboard.
  if (/\d/.test(event.data[0])) { // True IFF .data starts with a digit (command ID)
    // Clear pane if appropriate
    if (!keep_pane_contents) {
      pane.innerHTML = "";
      keep_pane_contents = true;
    }

    // Split message into [ID, CMD, MSG]
    msg_frags = event.data.split(":");
    id = msg_frags[0];
    cmd_type = msg_frags[1];
    msg = msg_frags.slice(2).join(":");
    // Validate
    if (!(id in commands) || !(["ERR", "OUT", "CLEAR", "FINISHED"].includes(cmd_type)) ) {
      console.log("Error validating message: " + event.data);
      return;
    }

    // Process message
    switch (cmd_type) {
      case "ERR":
        append_stream_content(id, "<span class=\"stderr\">" + msg + "</span>");
        break;
      case "OUT":
        append_stream_content(id, msg);
        break;
      case "CLEAR":
        commands[id]['content'] = "";
        update_pane();
        break;
      case "FINISHED":
        document.getElementById('cmd-' + id + '-run-icon').innerHTML = "Run";
        commands[id]['is_running'] = false;
        update_pane();
        break;
      default:
        console.log("Error: Message not understood. Id: " + id + ", cmd_type: " + cmd_type + ", msg:" + msg);
    }


  } else { // .data start with a non-digit character (it's about a dashboard).

    // Split message into [DASH, ELEMENT, MSG FRAG, DATA TYPE]
    msg_frags = event.data.split(":");
    dash_id = msg_frags[0][0];
    elem_id = parseInt(msg_frags[0].slice(1));
    if (msg_frags[1] != "A" ) { console.log("Error: fragmented dashboard update received. Not implemented yet.")}
    msg = msg_frags.slice(2).join(":");

    // Parse daashboard update msg
    data_type = parseInt(msg.split("->")[0]);
    msg = msg.split("->")[1];

    // Validate
    if (!(dash_id in dashboards) ||
        (dashboards[dash_id]['elements'][elem_id] == null) ||
        (data_type in dashboards[dash_id]['elements'][elem_id]['config']['data']['datasets'][data_type] == null) ) {
      console.log("Error validating dashboard update: " + event.data);
      return;
    }

    // Update Chart
    new_label = msg.split('"')[1];
    new_val = parseFloat(msg.split('"')[3]);
    append_time_series_data(dash_id, elem_id, data_type, new_label, new_val)
    console.log("Valid dashboard update: " + event.data);
  }
}


function append_time_series_data(dash_id, elem_id, data_type, new_label, new_value) {

  chart = dashboards[dash_id]['elements'][elem_id]['chart'];
  const data = chart.data;
  if (data_type == 0) { // Add a label from the 0th data type
    data.labels.push(new_label);
  }
  data.datasets[data_type].data.push(new_value); // push another data point
  chart.update();

  console.log("Appending: " + new_value);
}

/* append_stream_content
 *
 * Adds the contents of a message (content) to the output for a given id.
 */
function append_stream_content(id, content){
  console.log("Id: " + id + ", current_cmd: " + current_cmd + ", content: " + content);
  commands[id]['content'] += content;
  update_pane();
}

/* toggle_run
 *
 * Sends a message to the server to stop or run the given id (dependent on its
 * state), and updates the run/stop button accordingly.
 */
function toggle_run(id){
  if (commands[id]['is_running']) { // STOP (already running)
    ws_socket.send("STOP:" + id);
    document.getElementById('cmd-' + id + '-run-icon').innerHTML = "Run";
  } else { // RUN (currently not running)
    commands[id]['content'] = "";
    ws_socket.send("RUN:" + id);
    document.getElementById('cmd-' + id + '-run-icon').innerHTML = "Stop";
    current_cmd = id;
  }
  commands[id]['is_running'] = !commands[id]['is_running'];
  update_pane();
}

/* load_pane
 *
 * Loads the output/dashboard associated with the id.
 */
function load_pane(id) {
  current_cmd = id;
  update_pane();
}

/* updates_pane
 *
 * Updates the contents of the pane. Typically called after a message has been
 * received that wants to put new content onto the pane.
 */
function update_pane() {
  pane = document.getElementById('output-pane');
  pane_state = document.getElementById('interface-state');
  pane_state_details = document.getElementById('interface-state-details');


  if (Number.isInteger(current_cmd)){
    if (commands[current_cmd]['is_running']) {
      pane_state.innerHTML = "Running: ";
    } else {
      pane_state.innerHTML = "Output Of: ";
    }
    pane_state_details.innerHTML = commands[current_cmd]['name'];
    pane.innerHTML = commands[current_cmd]['content'];
  } else { // is a dashboard
    pane_state.innerHTML = dashboards[current_cmd]['name'];
    pane_state_details.innerHTML = dashboards[current_cmd]['desc'];
    document.getElementById('dash-elem').appendChild(
      dashboards[current_cmd]['elements'][0]['canvas']
    );
  }
}

/* show_help_message
 *
 * Displays the help message on the pane. Called when the user clicks the 'help'
 * button.
 */
function show_help_message() {
  current_cmd = null;
  pane = document.getElementById('output-pane');
  pane_state = document.getElementById('interface-state');
  pane_state_details = document.getElementById('interface-state-details');
  pane.innerHTML =
    "Welcome to the CDash Dashboard! Programs are set up via a YAML file on the server.\n\n" +
    "You can run these programs by clicking 'Run' under a program's information.\n\n" +
    "Programs' output will update even if you are looking at the output of another program.\n\n" +
    "Use the 'Show' button to select which programs' output you are seeing.";
  pane_state.innerHTML = "Showing: ";
  pane_state_details = "Help Message";
}
